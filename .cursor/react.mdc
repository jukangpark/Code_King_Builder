# React & Next.js Guidelines

## Next.js App Router

### App Router Structure

```
src/app/
├── layout.tsx              # Root layout
├── page.tsx                # Home page
├── loading.tsx             # Global loading UI
├── error.tsx               # Global error UI
├── not-found.tsx           # 404 page
├── [locale]/               # Internationalized routes
│   ├── layout.tsx          # Locale-specific layout
│   ├── page.tsx            # Locale home page
│   └── about/
│       └── page.tsx        # About page
└── api/                    # API routes
    └── users/
        └── route.ts        # API endpoint
```

### Server vs Client Components

#### Server Components (Default)

```typescript
// ✅ Good - Server Component (default)
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "About Us",
  description: "Learn more about our company",
};

export default async function AboutPage() {
  // Can directly access databases, file systems, etc.
  const data = await fetch("https://api.example.com/data");
  const posts = await data.json();

  return (
    <div>
      <h1>About Us</h1>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}
```

#### Client Components

```typescript
"use client";

import { useState, useEffect } from "react";

export default function InteractiveComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Client-side logic
    const timer = setInterval(() => {
      setCount((prev) => prev + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

### Layout Patterns

```typescript
// Root layout
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          <Navigation />
          <main>{children}</main>
          <Footer />
        </AuthProvider>
      </body>
    </html>
  );
}

// Nested layout
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="dashboard">
      <Sidebar />
      <div className="content">{children}</div>
    </div>
  );
}
```

## React Patterns

### Component Design Principles

#### Single Responsibility

```typescript
// ✅ Good - Single responsibility
interface UserCardProps {
  user: IUser;
  onEdit: (user: IUser) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user)}>Edit</button>
    </div>
  );
};

// ❌ Bad - Multiple responsibilities
const UserCardWithEditForm: React.FC<UserCardProps> = ({ user }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState(user);

  // Too many responsibilities in one component
  return (
    <div>
      {/* User display logic */}
      {/* Edit form logic */}
      {/* Validation logic */}
    </div>
  );
};
```

#### Composition over Inheritance

```typescript
// ✅ Good - Composition
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
};

// Usage
<Modal isOpen={showModal} onClose={() => setShowModal(false)}>
  <UserForm user={selectedUser} onSubmit={handleSubmit} />
</Modal>;
```

### State Management

#### Local State

```typescript
// ✅ Good - Local state for component-specific data
const UserForm: React.FC<UserFormProps> = ({ user, onSubmit }) => {
  const [formData, setFormData] = useState(user);
  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleInputChange = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: "" }));
    }
  };

  return <form onSubmit={handleSubmit}>{/* Form fields */}</form>;
};
```

#### Context for Global State

```typescript
// ✅ Good - Context for global state
interface AuthContextType {
  user: IUser | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<IUser | null>(null);
  const [loading, setLoading] = useState(true);

  // Auth logic here

  return (
    <AuthContext.Provider value={{ user, loading, signIn, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};
```

### Custom Hooks

#### Data Fetching Hook

```typescript
// ✅ Good - Custom hook for data fetching
function useUser(userId: string) {
  const [user, setUser] = useState<IUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await userService.getUser(userId);
        setUser(userData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to fetch user");
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]);

  return { user, loading, error };
}

// Usage
const UserProfile: React.FC<{ userId: string }> = ({ userId }) => {
  const { user, loading, error } = useUser(userId);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return <div>{user.name}</div>;
};
```

#### Form Hook

```typescript
// ✅ Good - Custom hook for form management
function useForm<T>(initialValues: T, validationSchema?: ValidationSchema<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});

  const handleChange = (field: keyof T, value: T[keyof T]) => {
    setValues((prev) => ({ ...prev, [field]: value }));

    // Clear error when user starts typing
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: undefined }));
    }
  };

  const handleBlur = (field: keyof T) => {
    setTouched((prev) => ({ ...prev, [field]: true }));

    // Validate field
    if (validationSchema) {
      const fieldError = validationSchema[field]?.(values[field]);
      if (fieldError) {
        setErrors((prev) => ({ ...prev, [field]: fieldError }));
      }
    }
  };

  const handleSubmit = (onSubmit: (values: T) => void) => {
    return (e: React.FormEvent) => {
      e.preventDefault();

      // Validate all fields
      if (validationSchema) {
        const newErrors: Partial<Record<keyof T, string>> = {};
        Object.keys(validationSchema).forEach((field) => {
          const error = validationSchema[field as keyof T]?.(
            values[field as keyof T]
          );
          if (error) {
            newErrors[field as keyof T] = error;
          }
        });

        if (Object.keys(newErrors).length > 0) {
          setErrors(newErrors);
          return;
        }
      }

      onSubmit(values);
    };
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
  };
}
```

### Event Handling

#### Form Events

```typescript
// ✅ Good - Form event handling
const LoginForm: React.FC = () => {
  const [formData, setFormData] = useState({
    email: "",
    password: "",
  });

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    try {
      await authService.signIn(formData.email, formData.password);
      // Handle success
    } catch (error) {
      // Handle error
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleInputChange}
        required
      />
      <input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleInputChange}
        required
      />
      <button type="submit">Sign In</button>
    </form>
  );
};
```

#### Click Events

```typescript
// ✅ Good - Click event handling
const ProductCard: React.FC<ProductCardProps> = ({ product, onAddToCart }) => {
  const handleAddToCart = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    e.stopPropagation();
    onAddToCart(product);
  };

  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p>{product.price}</p>
      <button onClick={handleAddToCart}>Add to Cart</button>
    </div>
  );
};
```

### Performance Optimization

#### Memoization

```typescript
// ✅ Good - Memo for expensive calculations
const ExpensiveComponent: React.FC<{ items: Item[] }> = ({ items }) => {
  const expensiveValue = useMemo(() => {
    return items.reduce((sum, item) => sum + item.value, 0);
  }, [items]);

  return <div>Total: {expensiveValue}</div>;
};

// ✅ Good - Memo for preventing unnecessary re-renders
const UserList: React.FC<{ users: IUser[] }> = React.memo(({ users }) => {
  return (
    <ul>
      {users.map((user) => (
        <UserItem key={user.id} user={user} />
      ))}
    </ul>
  );
});
```

#### Callback Memoization

```typescript
// ✅ Good - Memoized callbacks
const ParentComponent: React.FC = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  const handleReset = useCallback(() => {
    setCount(0);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <ChildComponent onIncrement={handleIncrement} onReset={handleReset} />
    </div>
  );
};
```

### Error Boundaries

```typescript
// ✅ Good - Error boundary component
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong.</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Best Practices

### 1. Component Organization

- Keep components small and focused
- Use composition over inheritance
- Separate concerns (UI, logic, data)
- Use custom hooks for reusable logic

### 2. State Management

- Use local state for component-specific data
- Use context for global state
- Consider external state management for complex apps
- Avoid prop drilling

### 3. Performance

- Use React.memo for expensive components
- Use useMemo for expensive calculations
- Use useCallback for stable function references
- Implement proper key props for lists

### 4. Error Handling

- Use error boundaries for component errors
- Handle async errors properly
- Provide meaningful error messages
- Implement fallback UI

### 5. Accessibility

- Use semantic HTML elements
- Provide proper ARIA labels
- Ensure keyboard navigation
- Test with screen readers

---

_Follow these React and Next.js patterns for maintainable and performant applications._
